name: ci-cd (manual)

on:
  workflow_dispatch:
    inputs:
      namespace:
        description: "Kubernetes namespace (default = repo name)"
        required: false
      replicas:
        description: "Deployment replicas"
        required: false
      image_tag:
        description: "Override image tag (optional)"
        required: false

env:
  REGISTRY: ghcr.io
  PYTHON_VERSION: "3.12"
  SERVICE_NAME: ${{ github.event.repository.name }}
  NAMESPACE:   ${{ github.event.repository.name }}
  APPLICATION_PORT: "8080"
  REPLICAS: "1"

jobs:
  publish-docker-image:
    if: ${{ github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      packages: write
    outputs:
      image: ${{ steps.out.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Lowercase repo
        id: repo
        run: echo "repo_lc=${GITHUB_REPOSITORY,,}" >> "$GITHUB_OUTPUT"

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Define tags
        id: tags
        run: |
          echo "TAG_SHA=${{ env.REGISTRY }}/${{ steps.repo.outputs.repo_lc }}:sha-${{ github.sha }}" >> "$GITHUB_OUTPUT"
          echo "TAG_MAIN=${{ env.REGISTRY }}/${{ steps.repo.outputs.repo_lc }}:${{ inputs.image_tag || 'manual' }}" >> "$GITHUB_OUTPUT"

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ steps.tags.outputs.TAG_SHA }}
            ${{ steps.tags.outputs.TAG_MAIN }}
          build-args: |
            PYTHON_VERSION=${{ env.PYTHON_VERSION }}

      - name: Expose immutable image output
        id: out
        run: echo "image=${{ steps.tags.outputs.TAG_SHA }}" >> "$GITHUB_OUTPUT"

  deploy:
    if: ${{ github.event_name == 'workflow_dispatch' }}
    needs: publish-docker-image
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install envsubst
        run: |
          sudo apt-get update
          sudo apt-get install -y gettext-base

      - name: Set up kubeconfig (namespaced access only)
        env:
          KUBECONFIG_CONTENT: ${{ secrets.KUBECONFIG }}
        run: |
          mkdir -p "$HOME/.kube"
          printf "%s" "$KUBECONFIG_CONTENT" > "$HOME/.kube/config"

      - name: Ensure GHCR imagePullSecret (ghcr-pull) in namespace
        env:
          NS: ${{ inputs.namespace || env.NAMESPACE }}
          REGISTRY: ${{ env.REGISTRY }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
        run: |
          set -euo pipefail
          if [[ -n "${GHCR_USERNAME:-}" && -n "${GHCR_TOKEN:-}" ]]; then
            echo "Creating/updating docker-registry secret ghcr-pull in namespace ${NS}..."
            kubectl -n "$NS" create secret docker-registry ghcr-pull \
              --docker-server="$REGISTRY" \
              --docker-username="${GHCR_USERNAME}" \
              --docker-password="${GHCR_TOKEN}" \
              --dry-run=client -o yaml | kubectl -n "$NS" apply -f -
          else
            echo "GHCR_USERNAME/GHCR_TOKEN not set. Skipping imagePullSecret creation."
          fi

      - name: Render manifests with image & vars (envsubst)
        env:
          IMAGE:            ${{ needs.publish-docker-image.outputs.image }}
          SERVICE_NAME:     ${{ env.SERVICE_NAME }}
          NAMESPACE:        ${{ inputs.namespace || env.NAMESPACE }}
          APPLICATION_PORT: ${{ env.APPLICATION_PORT }}
          REPLICAS:         ${{ inputs.replicas || env.REPLICAS }}
          BATCH_SIZE: "12"
          MAX_WAIT_MS: "12"
          SENTENCE_POLICY: "reject_new"
          WORD_POLICY: "drop_oldest"
          GPU_COUNT: "1"
          CPU_REQUESTS: "500m"
          CPU_LIMITS: "2"
          MEM_REQUESTS: "2Gi"
          MEM_LIMITS: "8Gi"
          PVC_NAME: "hf-cache-${{ env.SERVICE_NAME }}"
          AUTH_SECRET_NAME: "auth-tokens-${{ env.SERVICE_NAME }}"
          AUTH_TOKENS: ${{ secrets.AUTH_TOKENS }}
        run: |
          set -euo pipefail
          [ -n "${IMAGE:-}" ] || { echo "ERROR: IMAGE is empty."; exit 1; }
          envsubst < deployment.yaml > /tmp/rendered.yaml
          echo "---- rendered (head) ----"
          sed -n '1,200p' /tmp/rendered.yaml
          echo "--------------------------"
          grep -E 'image:\s*[^ ]' /tmp/rendered.yaml >/dev/null || { echo "Rendered manifest missing image"; exit 1; }

      - name: Apply manifests (namespaced only)
        run: |
          set -euo pipefail
          kubectl apply -f /tmp/rendered.yaml

      - name: Pin image explicitly (namespaced)
        env:
          NAMESPACE:    ${{ inputs.namespace || env.NAMESPACE }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          IMAGE:        ${{ needs.publish-docker-image.outputs.image }}
        run: |
          kubectl -n "$NAMESPACE" set image deploy/${SERVICE_NAME} ${SERVICE_NAME}=${IMAGE} --record || true

      - name: Rollout status
        env:
          NAMESPACE:    ${{ inputs.namespace || env.NAMESPACE }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
        run: |
          kubectl -n "$NAMESPACE" rollout status deploy/${SERVICE_NAME} --timeout=180s
